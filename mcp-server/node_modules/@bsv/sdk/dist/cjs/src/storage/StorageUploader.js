"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StorageUploader = void 0;
const AuthFetch_js_1 = require("../auth/clients/AuthFetch.js");
const StorageUtils = __importStar(require("./StorageUtils.js"));
class StorageUploader {
    constructor(config) {
        this.baseURL = config.storageURL;
        this.authFetch = new AuthFetch_js_1.AuthFetch(config.wallet);
    }
    async getUploadInfo(fileSize, retentionPeriod) {
        const url = `${this.baseURL}/upload`;
        const body = { fileSize, retentionPeriod };
        const response = await this.authFetch.fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
        });
        if (!response.ok) {
            throw new Error(`Upload info request failed: HTTP ${response.status}`);
        }
        const data = await response.json();
        if (data.status === 'error') {
            throw new Error('Upload route returned an error.');
        }
        return {
            uploadURL: data.uploadURL,
            requiredHeaders: data.requiredHeaders,
            amount: data.amount
        };
    }
    async uploadFile(uploadURL, file, requiredHeaders) {
        const body = Uint8Array.from(file.data);
        const response = await fetch(uploadURL, {
            method: 'PUT',
            body,
            headers: {
                'Content-Type': file.type,
                ...requiredHeaders
            }
        });
        if (!response.ok) {
            throw new Error(`File upload failed: HTTP ${response.status}`);
        }
        const uhrpURL = await StorageUtils.getURLForFile(file.data);
        return {
            published: true,
            uhrpURL
        };
    }
    /**
       * Publishes a file to the storage server with the specified retention period.
       *
       * This will:
       * 1. Request an upload URL from the server.
       * 2. Perform an HTTP PUT to upload the file’s raw bytes.
       * 3. Return a UHRP URL referencing the file once published.
       *
       * @param params.file - An object describing the file’s data (number[] array of bytes) and mime type.
       * @param params.retentionPeriod - Number of minutes to keep the file hosted.
       *
       * @returns An object indicating whether the file was published successfully and the resulting UHRP URL.
       *
       * @throws If either the upload info request or the subsequent file upload request fails (non-OK HTTP status).
       */
    async publishFile(params) {
        const { file, retentionPeriod } = params;
        const fileSize = file.data.length;
        const { uploadURL, requiredHeaders } = await this.getUploadInfo(fileSize, retentionPeriod);
        return await this.uploadFile(uploadURL, file, requiredHeaders);
    }
}
exports.StorageUploader = StorageUploader;
//# sourceMappingURL=StorageUploader.js.map